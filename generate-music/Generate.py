import glob
import pickle
import numpy as np
from music21 import converter, instrument, chord, stream, note
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras.utils import np_utils
import sys

def reload_network_and_generate(X, unique_size):
    model = Sequential()
    model.add(LSTM(256, batch_input_shape=(64, X.shape[1], X.shape[2]), return_sequences=True, stateful=True))
    model.add(Dropout(0.2))
    model.add(LSTM(256, return_sequences=False, stateful=False))
    model.add(Dropout(0.2))
    model.add(Dense(unique_size, activation="softmax"))
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=["accuracy"])
    # Load the weights
    model.load_weights('C:/Users/PycharmProjects/AI-music/generate-music/model_weights.hdf5')

    return model


def network_input_output(info, unique_size, length):
    X = []

    # integers -> notes
    unique_info = sorted(set(item for item in info))  # get all pitches
    unique_info_dict = dict((note, number) for number, note in enumerate(unique_info))

    for i in range(0, len(info) - length, 1):
        Xs = info[i:i + length]
        X.append([unique_info_dict[char] for char in Xs])

    Xn = np.reshape(X, (len(X), length, 1))
    Xn = Xn / float(unique_size) #normalize

    return (X, Xn)



def predict_and_create_midi(model, X, unique_info, unique_size):

    int_to_note = dict((number, note) for number, note in enumerate(unique_info))
    Y_pred = [] 

    random = np.random.randint(0, len(X) - 1)
    seq = X[random] #sequence of music information
    
    for number in range(300):
        X_pred = np.reshape(seq, (1, len(seq), 1))
        X_pred = X_pred / float(unique_size)
        pred = model.predict(X_pred, verbose=0)
        best = np.argmax(pred) #taking the  muisic info with the highest probability  
        best_info = int_to_note[best]  # un-encoding
        Y_pred.append(best_info)
        seq.append(best)
        seq = seq[1:len(seq)] #create the next sequence

    song = []
    offset= 0.5
    # create note and chord objects based on the values generated by the model
    for info in predictions:
        # info=chord
        if ('.' in info) or info.isdigit():
            chord_notes = info.split('.')
            notes = []
            for current in chord_notes:
                new_note = note.Note(int(current))
                new_note.offset = offset
                new_note.storedInstrument = instrument.SnareDrum()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            song.append(new_chord)
        # info = Rest
        elif ('Re' in info):
            new_rest= note.Rest()
            new_rest.offset = offset
            new_rest.quarterLength = float(info[1:])
            new_rest.storedInstrument = instrument.SnareDrum()
            song.append(new_rest)
        # info = note
        else:
            new_note = note.Note(info)
            new_note.offset = offset
            new_note.storedInstrument = instrument.SnareDrum()
            song.append(new_note)
        offset += 0.5
    midi = stream.Stream(song)
    midi.write('midi', fp='C:/Users/PycharmProjects/AI-music/generate-music/generated_song.mid')

def generate():

    with open('C:/Users/PycharmProjects/AI-music/generate-music/info', 'rb') as filepath:
        info = pickle.load(filepath)
    input_length = 50
    # Get all unique information form data set
    unique_info = sorted(set(item for item in info))
    unique_size = len(set(info))
    X, Xn = network_input_output(info, unique_size, input_length)
    model = reload_network_and_generate(Xn, unique_size)
    predict_and_create_midi(model,X,unique_info, unique_size)
    

def convertor(out, s):

    if(out == "Flute"):
        print("Flute")
        for p in s.parts:
            p.insert(0, instrument.Flute())
        s.write('midi', 'C:/Users/Ciprian/PycharmProjects/AI-music/static/midi/Flute.mid')
    
    elif (out == "Violin"):
        print("Violin")
        for p in s.parts:
            p.insert(0, instrument.Violin())
        s.write('midi', 'C:/Users/Ciprian/PycharmProjects/AI-music/static/midi/Violin.mid')
    
    elif (out == "Piano"):
        print("Piano")
        for p in s.parts:
            p.insert(0, instrument.Piano())
        s.write('midi', 'C:/Users/Ciprian/PycharmProjects/AI-music/static/midi/Piano.mid')
    elif (out == "Celesta"):
        print("Celesta")
        for p in s.parts:
            p.insert(0, instrument.Celesta())
    s.write('midi', 'C:/Users/Ciprian/PycharmProjects/AI-music/static/midi/Celesta.mid')

    
def start():

    generate()
    s = converter.parse('C:/Users/PycharmProjects/AI-music/generate-music/generated_song.mid')
    out= sys.argv[1]
    convertor(out, s)

start()
